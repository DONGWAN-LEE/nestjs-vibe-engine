/**
 * Setup Wizard Express 서버
 *
 * NestJS 모듈 시스템 밖에서 독립 동작하는 경량 Express 서버입니다.
 * .env 파일 생성 → DB 연결 테스트 → Prisma 마이그레이션 → NestJS 앱 시작까지 처리합니다.
 *
 * @module setup
 */

import { existsSync, readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import { execSync } from 'child_process';
import type { Socket } from 'net';
import type { Request, Response } from 'express';
import * as express from 'express';
import * as mysql from 'mysql2/promise';
import { renderChoicePage, renderSetupPage } from './setup.html';
import {
  ENV_DEFINITIONS,
  buildDatabaseUrl,
  parseDatabaseUrl,
} from './env-definitions';

type SSEClient = Response;

interface DbConnectOptions {
  host: string;
  port: number;
  user: string;
  password: string;
}

/**
 * MySQL 서버 연결 테스트 (DB 지정 없이 서버만 확인)
 */
async function testMysqlConnection(
  opts: DbConnectOptions,
): Promise<{ success: true } | { success: false; message: string }> {
  let conn: mysql.Connection | null = null;
  try {
    conn = await mysql.createConnection({
      host: opts.host,
      port: opts.port,
      user: opts.user,
      password: opts.password,
      connectTimeout: 10000,
    });
    await conn.query('SELECT 1');
    return { success: true };
  } catch (e: unknown) {
    const msg = e instanceof Error ? e.message : String(e);
    return { success: false, message: msg };
  } finally {
    if (conn) await conn.end().catch(() => {});
  }
}

/**
 * 데이터베이스 생성 (없으면 생성, 있으면 그대로)
 */
async function ensureDatabase(
  opts: DbConnectOptions,
  dbName: string,
): Promise<{ created: boolean; existed: boolean; error?: string }> {
  let conn: mysql.Connection | null = null;
  try {
    conn = await mysql.createConnection({
      host: opts.host,
      port: opts.port,
      user: opts.user,
      password: opts.password,
      connectTimeout: 10000,
    });

    const [rows] = await conn.query(
      'SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = ?',
      [dbName],
    );
    const existed = (rows as unknown[]).length > 0;

    if (!existed) {
      await conn.query(
        `CREATE DATABASE \`${dbName}\` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci`,
      );
    }

    return { created: !existed, existed };
  } catch (e: unknown) {
    const msg = e instanceof Error ? e.message : String(e);
    return { created: false, existed: false, error: msg };
  } finally {
    if (conn) await conn.end().catch(() => {});
  }
}

let sseClients: SSEClient[] = [];

function broadcastSSE(data: {
  step: string;
  status: string;
  message: string;
}): void {
  const payload = `data: ${JSON.stringify(data)}\n\n`;
  for (const client of sseClients) {
    client.write(payload);
  }
}

/**
 * 기존 .env 파일에서 환경변수를 파싱합니다.
 */
function parseEnvFile(filePath: string): Record<string, string> {
  const result: Record<string, string> = {};
  if (!existsSync(filePath)) return result;

  const content = readFileSync(filePath, 'utf-8');
  for (const line of content.split('\n')) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    const eqIdx = trimmed.indexOf('=');
    if (eqIdx === -1) continue;
    const key = trimmed.slice(0, eqIdx).trim();
    let value = trimmed.slice(eqIdx + 1).trim();
    if (
      (value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }
    result[key] = value;
  }
  return result;
}

/**
 * DATABASE_URL에서 DB 개별 필드를 추출하여 기존 값에 병합합니다.
 */
function enrichWithDbFields(
  values: Record<string, string>,
): Record<string, string> {
  if (values['DATABASE_URL']) {
    const parsed = parseDatabaseUrl(values['DATABASE_URL']);
    if (!values['DB_HOST']) values['DB_HOST'] = parsed.host;
    if (!values['DB_PORT']) values['DB_PORT'] = parsed.port;
    if (!values['DB_USER']) values['DB_USER'] = parsed.user;
    if (!values['DB_PASSWORD']) values['DB_PASSWORD'] = parsed.password;
    if (!values['DB_NAME']) values['DB_NAME'] = parsed.dbName;
  }
  return values;
}

/**
 * 폼 데이터에서 .env 파일 내용을 생성합니다.
 */
function buildEnvContent(data: Record<string, string>): string {
  const databaseUrl = buildDatabaseUrl(
    data['DB_HOST'] || 'localhost',
    data['DB_PORT'] || '3306',
    data['DB_USER'] || 'root',
    data['DB_PASSWORD'] || '',
    data['DB_NAME'] || 'nestjs_engine_db',
  );

  const lines: string[] = [
    '# NestJS Engine Environment Configuration',
    `# Generated by Setup Wizard at ${new Date().toISOString()}`,
    '',
    '# App',
  ];

  const groupOrder = ['app', 'database', 'redis', 'auth', 'etc'];
  const groupComments: Record<string, string> = {
    app: '# App',
    database: '# Database',
    redis: '# Redis',
    auth: '# Auth / Security',
    etc: '# Etc',
  };

  for (const group of groupOrder) {
    lines.push('');
    lines.push(groupComments[group] || `# ${group}`);

    if (group === 'database') {
      lines.push(`DATABASE_URL=${databaseUrl}`);
      continue;
    }

    const defs = ENV_DEFINITIONS.filter((d) => d.group === group);
    for (const def of defs) {
      const value = data[def.key] ?? def.defaultValue;
      if (
        def.key.startsWith('DB_') &&
        ['DB_HOST', 'DB_PORT', 'DB_USER', 'DB_PASSWORD', 'DB_NAME'].includes(
          def.key,
        )
      ) {
        continue;
      }
      lines.push(`${def.key}=${value}`);
    }
  }

  lines.push('');
  return lines.join('\n');
}

/**
 * Setup Wizard Express 서버를 시작합니다.
 *
 * Promise를 반환하며, 사용자가 "기존 설정 사용" 또는 Setup 완료 시 resolve됩니다.
 */
export async function startSetupServer(
  port: number,
  forceSetup: boolean,
): Promise<void> {
  const envPath = join(process.cwd(), '.env');
  const envExists = existsSync(envPath);

  return new Promise<void>((resolve, reject) => {
    const app = express();
    app.use(express.json());
    app.use(express.urlencoded({ extended: true }));

    let server: ReturnType<typeof app.listen>;
    const openSockets = new Set<Socket>();

    function shutdown(): void {
      for (const client of sseClients) {
        client.end();
      }
      sseClients = [];
      // 열린 소켓을 모두 강제 종료하여 server.close()가 즉시 완료되도록 함
      for (const socket of openSockets) {
        socket.destroy();
      }
      openSockets.clear();
      if (server) {
        server.close();
      }
    }

    // GET / - 메인 페이지
    app.get('/', (req: Request, res: Response) => {
      const mode = req.query.mode as string | undefined;

      if (envExists && !forceSetup && mode !== 'setup') {
        res.type('html').send(renderChoicePage());
        return;
      }

      const existingValues = envExists
        ? enrichWithDbFields(parseEnvFile(envPath))
        : {};
      res.type('html').send(renderSetupPage(existingValues));
    });

    // GET /setup/status - SSE 진행 상태
    app.get('/setup/status', (_req: Request, res: Response) => {
      res.setHeader('Content-Type', 'text/event-stream');
      res.setHeader('Cache-Control', 'no-cache');
      res.setHeader('Connection', 'keep-alive');
      res.flushHeaders();

      sseClients.push(res);

      res.on('close', () => {
        sseClients = sseClients.filter((c) => c !== res);
      });
    });

    // POST /setup/test-db - DB 연결 테스트 + DB 없으면 자동 생성
    app.post('/setup/test-db', async (req: Request, res: Response) => {
      const data = req.body as Record<string, string>;
      const connOpts: DbConnectOptions = {
        host: data['DB_HOST'] || 'localhost',
        port: parseInt(data['DB_PORT'] || '3306', 10),
        user: data['DB_USER'] || 'root',
        password: data['DB_PASSWORD'] || '',
      };
      const dbName = data['DB_NAME'] || 'nestjs_engine_db';

      // 1) MySQL 서버 연결 테스트
      const connResult = await testMysqlConnection(connOpts);
      if (!connResult.success) {
        res.json({
          success: false,
          message: `MySQL 서버 연결 실패 (${connOpts.host}:${connOpts.port}) - ${connResult.message}`,
        });
        return;
      }

      // 2) DB 존재 확인 → 없으면 자동 생성
      const dbResult = await ensureDatabase(connOpts, dbName);
      if (dbResult.error) {
        res.json({
          success: false,
          message: `데이터베이스 '${dbName}' 생성 실패 - ${dbResult.error}`,
        });
        return;
      }

      res.json({
        success: true,
        dbExists: dbResult.existed,
        message: dbResult.created
          ? `연결 성공! 데이터베이스 '${dbName}'을(를) 새로 생성했습니다.`
          : `연결 성공! 데이터베이스 '${dbName}'이(가) 존재합니다.`,
      });
    });

    // POST /setup - 환경변수 저장 + DB 초기화
    app.post('/setup', async (req: Request, res: Response) => {
      const data = req.body as Record<string, string>;

      try {
        // Step 1: .env 파일 저장
        broadcastSSE({
          step: 'env',
          status: 'running',
          message: '.env 파일 저장 중...',
        });

        const envContent = buildEnvContent(data);
        writeFileSync(envPath, envContent, 'utf-8');

        broadcastSSE({
          step: 'env',
          status: 'done',
          message: '.env 파일 저장 완료',
        });

        // Step 2: DB 연결 테스트 + 데이터베이스 자동 생성
        const dbHost = data['DB_HOST'] || 'localhost';
        const dbPort = data['DB_PORT'] || '3306';
        const dbUser = data['DB_USER'] || 'root';
        const dbPass = data['DB_PASSWORD'] || '';
        const dbName = data['DB_NAME'] || 'nestjs_engine_db';
        const connOpts: DbConnectOptions = {
          host: dbHost,
          port: parseInt(dbPort, 10),
          user: dbUser,
          password: dbPass,
        };

        // 2a: MySQL 서버 연결 테스트
        broadcastSSE({
          step: 'db-test',
          status: 'running',
          message: 'MySQL 서버 연결 테스트 중...',
        });

        const connResult = await testMysqlConnection(connOpts);
        if (!connResult.success) {
          broadcastSSE({
            step: 'db-test',
            status: 'error',
            message: `MySQL 서버 연결 실패 - ${connResult.message}`,
          });
          res.status(400).json({
            error: `MySQL 서버에 연결할 수 없습니다: ${connResult.message}`,
          });
          return;
        }

        broadcastSSE({
          step: 'db-test',
          status: 'done',
          message: 'MySQL 서버 연결 성공',
        });

        // 2b: 데이터베이스 존재 확인 및 자동 생성
        broadcastSSE({
          step: 'db-create',
          status: 'running',
          message: `데이터베이스 '${dbName}' 확인 중...`,
        });

        const dbResult = await ensureDatabase(connOpts, dbName);
        if (dbResult.error) {
          broadcastSSE({
            step: 'db-create',
            status: 'error',
            message: `데이터베이스 생성 실패: ${dbResult.error}`,
          });
          res.status(400).json({
            error: `데이터베이스 '${dbName}' 생성에 실패했습니다: ${dbResult.error}`,
          });
          return;
        }

        broadcastSSE({
          step: 'db-create',
          status: 'done',
          message: dbResult.created
            ? `데이터베이스 '${dbName}' 새로 생성 완료`
            : `데이터베이스 '${dbName}' 존재 확인 완료`,
        });

        const dbUrl = buildDatabaseUrl(dbHost, dbPort, dbUser, dbPass, dbName);

        // Step 3: Prisma generate
        broadcastSSE({
          step: 'prisma-generate',
          status: 'running',
          message: 'Prisma Client 생성 중...',
        });

        try {
          execSync('npx prisma generate', {
            cwd: process.cwd(),
            timeout: 60000,
            stdio: ['pipe', 'pipe', 'pipe'],
          });
        } catch (e: unknown) {
          const errMsg =
            e instanceof Error ? e.message : 'Prisma generate 실패';
          broadcastSSE({
            step: 'prisma-generate',
            status: 'error',
            message: `Prisma Client 생성 실패: ${errMsg}`,
          });
          res.status(500).json({
            error: `Prisma Client 생성 실패: ${errMsg}`,
          });
          return;
        }

        broadcastSSE({
          step: 'prisma-generate',
          status: 'done',
          message: 'Prisma Client 생성 완료',
        });

        // Step 4: Prisma db push (테이블 생성)
        broadcastSSE({
          step: 'prisma-push',
          status: 'running',
          message: 'DB 테이블 생성 중 (prisma db push)...',
        });

        try {
          execSync('npx prisma db push --accept-data-loss', {
            cwd: process.cwd(),
            timeout: 60000,
            stdio: ['pipe', 'pipe', 'pipe'],
            env: { ...process.env, DATABASE_URL: dbUrl },
          });
        } catch (e: unknown) {
          const errMsg =
            e instanceof Error ? e.message : 'Prisma db push 실패';
          broadcastSSE({
            step: 'prisma-push',
            status: 'error',
            message: `DB 테이블 생성 실패: ${errMsg}`,
          });
          res.status(500).json({
            error: `DB 테이블 생성 실패: ${errMsg}`,
          });
          return;
        }

        broadcastSSE({
          step: 'prisma-push',
          status: 'done',
          message: 'DB 테이블 생성 완료',
        });

        // Step 5: 완료
        broadcastSSE({
          step: 'finish',
          status: 'complete',
          message: '초기화 완료! NestJS 앱을 시작합니다...',
        });

        res.json({ success: true, message: 'Setup 완료' });

        // Express 서버 종료 → NestJS 부팅
        setTimeout(() => {
          shutdown();
          resolve();
        }, 1500);
      } catch (e: unknown) {
        const errMsg = e instanceof Error ? e.message : '알 수 없는 오류';
        broadcastSSE({
          step: 'unknown',
          status: 'error',
          message: errMsg,
        });
        res.status(500).json({ error: errMsg });
      }
    });

    // POST /setup/skip - 기존 설정으로 시작
    app.post('/setup/skip', (_req: Request, res: Response) => {
      res.json({ success: true, message: '기존 설정으로 시작합니다.' });
      setTimeout(() => {
        shutdown();
        resolve();
      }, 500);
    });

    server = app.listen(port, () => {
      const url = `http://localhost:${port}`;
      const logger = console;
      logger.info('');
      logger.info('  NestJS Engine - Setup Wizard');
      logger.info(`  ${url}`);
      logger.info('  브라우저에서 위 주소를 열어주세요');
      logger.info('');
    });

    // 열린 소켓 추적 (shutdown 시 강제 종료용)
    server.on('connection', (socket: Socket) => {
      openSockets.add(socket);
      socket.on('close', () => openSockets.delete(socket));
    });

    server.on('error', (err: Error) => {
      reject(
        new Error(`Setup 서버 시작 실패 (포트 ${port}): ${err.message}`),
      );
    });
  });
}
